#!/usr/bin/env python
from tornado import gen, ioloop, httpclient
from tornado.ioloop import IOLoop
import sys
from pkg_resources import iter_entry_points as iter_ep
import json
import logging
from sundaytasks.utils import get_provider
from sundaytasks.utils import get_extensions
import argparse
from tornado.escape import json_decode as jd
import traceback
import copy
FORMAT = '%(asctime)s %(funcName)s %(levelname)-8s %(message)s'
LEVEL = logging.DEBUG
logging.basicConfig(format = FORMAT, level = LEVEL)

@gen.coroutine
def main(plugin, args):
    response = yield plugin['receiver'](args)
    res_copy = copy.copy(response)
    for key in res_copy:
        value = res_copy[key]
        if type(value) is dict:
            for key2 in value:
                value2 = value[key2]
                if len(value2) > 100:
                    value[key2] = "Too long to display"
            res_copy[key] = value
        elif len(value) > 100:
            res_copy[key] = "Too long to display"
    logging.debug("Results: \n%s", json.dumps(res_copy, sort_keys=True,
    indent=4, separators=(',', ': ')))
    exit_res = {}
    if "exit" in args and "exit" in plugin:
        url = args["url"]
        database = args["database"]
        logging.debug("exit")
        try:
            receiver = EXTENSIONS["exit"][plugin['exit']]['receiver']
            exit_res = yield receiver(args['doc'], response, plugin['namespace'],
                                      url, database)
        except Exception, e:
            logging.debug("Exception: %s", str(e))
            traceback.print_exc()
            sys.exc_clear()
    exit_res_copy = copy.copy(exit_res)
    for key in exit_res_copy:
        value = exit_res_copy[key]
        if type(value) is dict:
            for key2 in value:
                value2 = value[key2]
                if len(value2) > 100:
                    value[key2] = "Too long to display"
            exit_res_copy[key] = value
        elif len(value) > 100:
            exit_res_copy[key] = "Too long to display"
    logging.debug("Exit results: \n%s", json.dumps(exit_res))

@gen.coroutine
def single(plugin, doc, url, database, exit):
    iplugin = __import__("%s" % plugin)
    print iplugin
    plugin = iplugin.PLUGIN
    if not doc:
        doc = {"_id": "testing", "username": "testing"}
    args = {"doc": doc, "url": url, "database": database, "exit": exit}
    if "provider" in plugin:
        provider = plugin["provider"]
        provider_res = yield get_provider(provider, EXTENSIONS, doc, url, database)
        args[provider] = provider_res
    logging.debug("args: %s", str(args))
    instance.add_callback(callback=lambda: main(plugin, args))
    instance.start()

if __name__ == "__main__":
    EXTENSIONS = get_extensions()
    #logging.debug("Extensions: %s", str(EXTENSIONS))
    instance = IOLoop.instance()
    description = """Test plugin tests the plugin to see if it works
    """
    parser = argparse.ArgumentParser(description=description)
    parser.add_argument('-p','--plugin', help='Plugin to test',
                         default=False)
    parser.add_argument('-d','--doc', help='Document to give',
                         default=False)
    parser.add_argument('--url', help='Url to use',
                         default=False)
    parser.add_argument('--database', help='Database to use',
                         default=False)
    parser.add_argument('-e', '--exit', action='store_true',
                         help='Turn on exit, requires url and database')
    args = parser.parse_args()
    if args.plugin:
        if args.doc:
            if args.url and args.database:
                http_client = httpclient.HTTPClient()
                try:
                    response = http_client.fetch(args.url+"/"+args.database+"/"+args.doc)
                except httpclient.HTTPError as e:
                    print("Error: %s", str(e))
                doc = response.body
                instance.run_sync(lambda: single(args.plugin, jd(doc), args.url, args.database, args.exit))
            else:
                instance.run_sync(lambda: single(args.plugin, jd(args.doc)))
        else:
            instance.run_sync(lambda: single(args.plugin, False))
    else:
        for object in iter_ep(group='sundaytasks.plugin', name=None):
            logging.debug("plugin: %s", str(object.name))
            plugin = object.load()
            instance.add_callback(callback=lambda: main(plugin, args))

        instance.start()
